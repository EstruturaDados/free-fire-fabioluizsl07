#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// --- ESTRUTURAS DE DADOS ---

/**
 * @brief Estrutura que representa um Componente necess√°rio para a Torre de Fuga.
 */
typedef struct {
    char nome[30];      // Nome do componente (ex: "Chip Central")
    char tipo[20];      // Tipo do componente (ex: "controle", "suporte", "propuls√£o")
    int prioridade;     // Prioridade de montagem (1=Alta, 10=Baixa)
} Componente;

// --- VARI√ÅVEIS GLOBAIS E CONSTANTES ---
#define MAX_COMPONENTES 20
Componente componentes[MAX_COMPONENTES];
int totalComponentes = 0;
char componenteChave[30] = "Chip Central"; // Componente a ser buscado

// Vari√°veis para medi√ß√£o de desempenho
long long contadorComparacoes = 0;
clock_t tempoInicial;
clock_t tempoFinal;

// --- FUN√á√ïES DE UTILIDADE E INTERFACE ---

/**
 * @brief Remove o caractere de nova linha (\n) lido por fgets.
 */
void removerNovaLinha(char *string) {
    size_t len = strlen(string);
    if (len > 0 && string[len - 1] == '\n') {
        string[len - 1] = '\0';
    }
}

/**
 * @brief Exibe o vetor de componentes de forma formatada.
 */
void mostrarComponentes() {
    printf("\n--- Componentes da Torre de Fuga (%d/%d) ---\n", totalComponentes, MAX_COMPONENTES);
    if (totalComponentes == 0) {
        printf("Nenhum componente cadastrado.\n");
        return;
    }
    printf("+------------------------------+--------------------+-----------+\n");
    printf("| Nome                         | Tipo               | Prioridade|\n");
    printf("+------------------------------+--------------------+-----------+\n");
    for (int i = 0; i < totalComponentes; i++) {
        printf("| %-28s | %-18s | %10d |\n", 
               componentes[i].nome, 
               componentes[i].tipo, 
               componentes[i].prioridade);
    }
    printf("+------------------------------+--------------------+-----------+\n");
}

/**
 * @brief Cadastra um novo componente na lista.
 */
void cadastrarComponente() {
    if (totalComponentes >= MAX_COMPONENTES) {
        printf("\nüö´ Capacidade m√°xima de %d componentes atingida.\n", MAX_COMPONENTES);
        return;
    }

    Componente novo;
    printf("\n--- Cadastro de Componente ---\n");
    
    // Leitura do Nome (usando fgets para seguran√ßa)
    printf("Nome do Componente: ");
    fgets(novo.nome, 30, stdin);
    removerNovaLinha(novo.nome);
    
    // Leitura do Tipo
    printf("Tipo (ex: controle, suporte, propulsao): ");
    fgets(novo.tipo, 20, stdin);
    removerNovaLinha(novo.tipo);

    // Leitura da Prioridade
    printf("Prioridade (1=Alta a 10=Baixa): ");
    while (scanf("%d", &novo.prioridade) != 1 || novo.prioridade < 1 || novo.prioridade > 10) {
        printf("Prioridade inv√°lida. Digite um n√∫mero entre 1 e 10: ");
        int c; while ((c = getchar()) != '\n' && c != EOF); // Limpa buffer
    }
    int c; while ((c = getchar()) != '\n' && c != EOF); // Limpa buffer ap√≥s o int

    componentes[totalComponentes] = novo;
    totalComponentes++;

    printf("\n‚úÖ Componente '%s' cadastrado com sucesso! (Total: %d/%d)\n", novo.nome, totalComponentes, MAX_COMPONENTES);
    mostrarComponentes();
}

// -------------------------------------------------------------------
//                          FUN√á√ïES DE ORDENA√á√ÉO
// -------------------------------------------------------------------

/**
 * @brief Bubble Sort para ordenar por Nome (Strings). O(n^2).
 */
void bubbleSortNome() {
    contadorComparacoes = 0;
    tempoInicial = clock();

    for (int i = 0; i < totalComponentes - 1; i++) {
        for (int j = 0; j < totalComponentes - 1 - i; j++) {
            // Compara√ß√£o de Strings
            contadorComparacoes++;
            if (strcmp(componentes[j].nome, componentes[j+1].nome) > 0) {
                // Troca (swap)
                Componente temp = componentes[j];
                componentes[j] = componentes[j+1];
                componentes[j+1] = temp;
            }
        }
    }

    tempoFinal = clock();
    printf("\n‚úÖ Ordena√ß√£o por NOME (Bubble Sort) conclu√≠da.\n");
    printf("   Compara√ß√µes realizadas: %lld\n", contadorComparacoes);
    printf("   Tempo de execu√ß√£o: %.6f segundos (O(n^2))\n", (double)(tempoFinal - tempoInicial) / CLOCKS_PER_SEC);
}

/**
 * @brief Insertion Sort para ordenar por Tipo (Strings). O(n^2).
 */
void insertionSortTipo() {
    contadorComparacoes = 0;
    tempoInicial = clock();

    for (int i = 1; i < totalComponentes; i++) {
        Componente chave = componentes[i];
        int j = i - 1;

        // Desloca os elementos maiores que a 'chave' uma posi√ß√£o para a frente
        while (j >= 0) {
            contadorComparacoes++;
            if (strcmp(componentes[j].tipo, chave.tipo) > 0) {
                componentes[j + 1] = componentes[j];
                j--;
            } else {
                break; // O elemento est√° na posi√ß√£o correta
            }
        }
        componentes[j + 1] = chave;
    }

    tempoFinal = clock();
    printf("\n‚úÖ Ordena√ß√£o por TIPO (Insertion Sort) conclu√≠da.\n");
    printf("   Compara√ß√µes realizadas: %lld\n", contadorComparacoes);
    printf("   Tempo de execu√ß√£o: %.6f segundos (O(n^2))\n", (double)(tempoFinal - tempoInicial) / CLOCKS_PER_SEC);
}

/**
 * @brief Selection Sort para ordenar por Prioridade (Inteiros). O(n^2).
 */
void selectionSortPrioridade() {
    contadorComparacoes = 0;
    tempoInicial = clock();

    for (int i = 0; i < totalComponentes - 1; i++) {
        int indiceMenor = i;
        
        // Encontra o √≠ndice do menor elemento restante
        for (int j = i + 1; j < totalComponentes; j++) {
            contadorComparacoes++;
            if (componentes[j].prioridade < componentes[indiceMenor].prioridade) {
                indiceMenor = j;
            }
        }
        
        // Troca (swap)
        if (indiceMenor != i) {
            Componente temp = componentes[i];
            componentes[i] = componentes[indiceMenor];
            componentes[indiceMenor] = temp;
        }
    }

    tempoFinal = clock();
    printf("\n‚úÖ Ordena√ß√£o por PRIORIDADE (Selection Sort) conclu√≠da.\n");
    printf("   Compara√ß√µes realizadas: %lld\n", contadorComparacoes);
    printf("   Tempo de execu√ß√£o: %.6f segundos (O(n^2))\n", (double)(tempoFinal - tempoInicial) / CLOCKS_PER_SEC);
}

// -------------------------------------------------------------------
//                            FUN√á√ÉO DE BUSCA
// -------------------------------------------------------------------

/**
 * @brief Busca Bin√°ria no vetor ordenado por Nome. O(log n).
 * @return O √≠ndice do componente, ou -1 se n√£o for encontrado.
 */
int buscaBinariaPorNome(const char *nomeBusca) {
    contadorComparacoes = 0;
    tempoInicial = clock();
    
    int inicio = 0;
    int fim = totalComponentes - 1;

    while (inicio <= fim) {
        int meio = inicio + (fim - inicio) / 2;
        int comparacao = strcmp(nomeBusca, componentes[meio].nome);
        
        contadorComparacoes++;
        
        if (comparacao == 0) {
            tempoFinal = clock();
            return meio; // Componente-chave encontrado
        } else if (comparacao < 0) {
            fim = meio - 1;
        } else {
            inicio = meio + 1;
        }
    }
    
    tempoFinal = clock();
    return -1; // Componente-chave n√£o encontrado
}


/**
 * @brief Executa a busca pelo componente-chave e exibe o desempenho.
 */
void buscarComponenteChave() {
    if (totalComponentes == 0) {
        printf("\nüö´ N√£o h√° componentes cadastrados para iniciar a busca.\n");
        return;
    }
    
    // A Busca Bin√°ria exige que o vetor esteja ordenado por NOME
    printf("\n--- Preparando busca: Ordenando por NOME para Busca Bin√°ria (O(log n))...\n");
    bubbleSortNome(); 
    mostrarComponentes(); // Exibe ap√≥s ordena√ß√£o
    
    int indice = buscaBinariaPorNome(componenteChave);

    printf("\n--- üîç Resultado da Busca Bin√°ria ---\n");
    if (indice != -1) {
        printf("‚úÖ O Componente-Chave '%s' foi **LOCALIZADO** no √≠ndice %d.\n", componenteChave, indice);
        printf("   Tipo: %s, Prioridade: %d.\n", componentes[indice].tipo, componentes[indice].prioridade);
    } else {
        printf("‚ùå O Componente-Chave '%s' **N√ÉO FOI ENCONTRADO**. A montagem n√£o pode come√ßar.\n", componenteChave);
    }
    
    printf("\n--- Desempenho da Busca ---\n");
    printf("Compara√ß√µes realizadas: %lld\n", contadorComparacoes);
    printf("Tempo de execu√ß√£o: %.6f segundos (O(log n))\n", (double)(tempoFinal - tempoInicial) / CLOCKS_PER_SEC);
}

// -------------------------------------------------------------------
//                             FUN√á√ÉO PRINCIPAL
// -------------------------------------------------------------------

void exibirMenuPrincipal() {
    printf("\n==========================================================\n");
    printf("‚öôÔ∏è ILHA HOSTIL - FASE 3: MONTAGEM DA TORRE DE FUGA\n");
    printf("==========================================================\n");
    printf("1. Cadastrar Componente (Total: %d/%d)\n", totalComponentes, MAX_COMPONENTES);
    printf("--- Estrat√©gias de Ordena√ß√£o (Medi√ß√£o de Desempenho) ---\n");
    printf("2. Ordenar por NOME (Bubble Sort)\n");
    printf("3. Ordenar por TIPO (Insertion Sort)\n");
    printf("4. Ordenar por PRIORIDADE (Selection Sort)\n");
    printf("--- Montagem Final ---\n");
    printf("5. Localizar Componente-Chave (Busca Bin√°ria - %s)\n", componenteChave);
    printf("6. Listar Componentes (Estado Atual)\n");
    printf("0. Finalizar Simula√ß√£o\n");
    printf("----------------------------------------------------------\n");
    printf("Escolha uma op√ß√£o: ");
}

int main() {
    int opcao;
    
    // Configura√ß√£o inicial para facilitar o teste
    totalComponentes = 4;
    strcpy(componentes[0].nome, "Suporte Principal"); strcpy(componentes[0].tipo, "suporte"); componentes[0].prioridade = 5;
    strcpy(componentes[1].nome, "Chip Central"); strcpy(componentes[1].tipo, "controle"); componentes[1].prioridade = 1;
    strcpy(componentes[2].nome, "Fus√≠vel de Energia"); strcpy(componentes[2].tipo, "controle"); componentes[2].prioridade = 8;
    strcpy(componentes[3].nome, "Motor de Propuls√£o"); strcpy(componentes[3].tipo, "propulsao"); componentes[3].prioridade = 3;

    printf("Iniciando a Fase 3: Estrat√©gia de Montagem da Torre.\n");

    do {
        exibirMenuPrincipal();
        
        if (scanf("%d", &opcao) != 1) {
            printf("\nOp√ß√£o inv√°lida. Digite um n√∫mero.\n");
            int c; while ((c = getchar()) != '\n' && c != EOF); 
            continue;
        }
        int c; while ((c = getchar()) != '\n' && c != EOF); // Limpa buffer ap√≥s o int

        if (totalComponentes == 0 && opcao > 1 && opcao < 6) {
             printf("\nüö´ Por favor, cadastre pelo menos um componente (Op√ß√£o 1) antes de ordenar/buscar.\n");
             continue;
        }
        
        switch (opcao) {
            case 1: cadastrarComponente(); break;
            case 2: bubbleSortNome(); mostrarComponentes(); break;
            case 3: insertionSortTipo(); mostrarComponentes(); break;
            case 4: selectionSortPrioridade(); mostrarComponentes(); break;
            case 5: buscarComponenteChave(); break;
            case 6: mostrarComponentes(); break;
            case 0: printf("\nüéâ Sucesso! A torre de fuga est√° pronta. Voc√™ escapou da ilha!\n"); break;
            default: printf("\nOp√ß√£o inv√°lida! Tente novamente.\n");
        }
        
        if (opcao != 0 && opcao != 5) {
            printf("\nPressione ENTER para continuar...");
            getchar();
        }

    } while (opcao != 0);

    return 0;
}
